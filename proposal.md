# Junebug by UWIT - Automated Device Status Detection
## Introducing Junebug ##
&emsp;&emsp;Junebug has been created to round out the service capabilities of the UWIT CTS team. In order to maintain equipment deployed across hundreds of rooms, technicians are assigned a portion of campus to preform routine preventative maintenance checks. This constant rotation of manual checks has allowed our team to find and remedy issues *before* a lecturer has to report it, but the time, staffing, and documentation requirements are a significant limitation on our capabilities.<br>
&emsp;&emsp;To alleviate this demand, resources have been built to automatically send out ICMP echoes to check for device activity on our Audio/Visual vLAN. While this allows for a quick scan at the Network layer, it is prone to false negatives and isn't very informative. To expand on the existing ICMP programming, Junebug leverages LLDP advertisements on local room switches to analyze device statuses for critical infrastructure and local network devices. Upon collecting this information, the resulting data is used to detect if a device has fallen offline, set alert statuses if needed, and update device uptime. This expansion on our remote servicing will reduce noise by minimizing ping commands while expanding the data we can utilize; having information on the LLDP advertisement stability of devices as well as access to locally-networked cameras and microphones will allow us to diagnose and begin servicing a problem before it interrupts a lecture.

## Accessing Junebug ##
&emsp;&emsp;This tool has been designed as a RESTful API living within the Data Center's VM. To retrieve processed room status data, Junebug includes queries to filter JSON data by priority, lifetime, and room/building. This API is Pythonic for ease of reading and portability, and uses separate thread pools to manage incoming HTTP requests and data collection seamlessly. This JSON data is intended to be accessed by other CTS tools. In order to collect this data, C has been chosen for its ability to open and maintain processes and its portable nature. 

## Resource Requirements ##
&emsp;&emsp;To access local LLDP information, ssh was deemed the most effective manner of interfacing with room switches remotely (a capability that would need afforded to the VM that Junebug lives within). This ability is currently unavailable to the CTS team as a whole, and would likely need extended to a testing environment before launching to a VM as well. Along with that, authorization to read LLDP records is crucial, but currently only available on Juniper-branded switches using CTS credentials. As Netgear-branded switches are becoming the standard for new classrooms, the ability to access LLDP records on these switches would be necessary as well. This increased accessibility, while unprecedented within the CTS team, will allow for service capabilities that are necessary to preserve the team's bandwidth as our responsibilities continue to grow.

## Security Considerations ##
&emsp;&emsp;Junebug in its current state operates as an HTTPS/TLS server, and any acomodations that need made to be compatible with the data center will be easy to make to incorporate ssh v2 compatibility. Along with TLS certificates, Basic authentication is used for POST requests as they are only available to developers configuring Junebug without unmounting the server. These POST requests will primarily be used to modify sleep calls to allow for necessary operations to complete and to whitelist anomalies that should be ignored. A scenario has been produced experimentally where a Netgear switch will ask for a password after the user is already logged in. In the event that this happens, a local and encrypted file will house the necessary verification, and a process will be instantiated to retrieve that password to send to the existing ssh process. <br>
&emsp;&emsp;Along with ensuring data is handled and communicated securely, measures have been taken to create secure code. Cyclic loops have been avoided in any Python code, allowing garbage collection to operate as intended. In all of the C code, all variables are initialized during runtime and all files or processes instantiated are terminated and closed. Due to the short runtime of C processes, memory bleed is avoided and ownership management is not required.